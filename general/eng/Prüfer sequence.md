---
aliases:
  - Prufer code
  - Prufer codes
  - Prufer number
  - Prufer numbers
  - Prufer sequence
  - Prufer sequences
  - Prüfer code
  - Prüfer codes
  - Prüfer number
  - Prüfer numbers
  - Prüfer sequence
  - Prüfer sequences
tags:
  - flashcard/active/general/eng/Prüfer_sequence
  - language/in/English
---

# Prüfer sequence

In {@{[combinatorial](combinatorics.md) [mathematics](mathematics.md)}@}, {@{the __Prüfer sequence__ (also __Prüfer code__ or __Prüfer numbers__) of a [labeled tree](tree%20(graph%20theory).md#labeled%20trees)}@} is {@{a unique [sequence](sequence.md) associated with the tree}@}. {@{The sequence for a tree on _n_ vertices}@} has {@{length _n_ − 2}@}, and can be {@{generated by a simple iterative algorithm}@}. Prüfer sequences were first used by {@{[Heinz Prüfer](Heinz%20Prüfer.md) to prove [Cayley's formula](cayley's%20formula.md) in 1918}@}.<sup>[\[1\]](#^ref-1)</sup>

## algorithm to convert a tree into a Prüfer sequence

One can {@{generate a labeled tree's Prüfer sequence}@} by {@{iteratively removing vertices from the tree until only two vertices remain}@}. Specifically, {@{consider a labeled tree _T_ with vertices {1, 2, ..., _n_}<!-- flashcard separator -->}@}. At {@{step _i_}@}, {@{remove the leaf with the smallest label and set the _i_-th element of the Prüfer sequence to be the label of this leaf's neighbour}@}.

The Prüfer sequence of a labeled tree is {@{unique and has length _n_ − 2}@}.

{@{Both coding and decoding}@} can be {@{reduced to integer radix sorting and parallelized}@}.<sup>[\[2\]](#^ref-2)</sup>

### example

> {@{![a labeled tree with Prüfer sequence](../../archives/Wikimedia%20Commons/Tree%20graph.svg)}@}
>
> {@{A labeled tree with Prüfer sequence {4,4,4,5}.}@}

Consider the above algorithm run on the tree shown to the right. Initially, vertex 1 is the leaf with the smallest label, so it is removed first and 4 is put in the Prüfer sequence. Vertices 2 and 3 are removed next, so 4 is added twice more. Vertex 4 is now a leaf and has the smallest label, so it is removed and we append 5 to the sequence. We are left with only two vertices, so we stop. The tree's sequence is {4,4,4,5}.

## algorithm to convert a Prüfer sequence into a tree

Let {@{`{a[1], a[2], ..., a[n]}`}@} be {@{a Prüfer sequence}@}:

The tree will {@{have `n+2` nodes, numbered from `1` to `n+2`}@}. For {@{each node}@} {@{set its degree to the number of times it appears in the sequence plus 1}@}. For instance, in pseudo-code:

<pre>
<b>Convert-Prüfer-to-Tree</b>(<i>a</i>)
 1 <i>n</i> ← <i>length</i>[<i>a</i>]
 2 <i>T</i> ← a graph with <i>n</i> + 2 isolated nodes, numbered 1 <b>to</b> <i>n</i> + 2
 3 <i>degree</i> ← an array of integers
 4 <b>for</b> each node <i>i</i> in <i>T</i> <b>do</b>
 5     <i>degree</i>[<i>i</i>] ← 1
 6 <b>for</b> each value <i>i</i> in <i>a</i> <b>do</b>
 7     <i>degree</i>[<i>i</i>] ← <i>degree</i>[<i>i</i>] + 1
</pre>

> [!info]- code
>
> ```pseudocode
> Convert-Prüfer-to-Tree(a)
>  1 n ← length[a]
>  2 T ← a graph with n + 2 isolated nodes, numbered 1 to n + 2
>  3 degree ← an array of integers
>  4 for each node i in T do
>  5     degree[i] ← 1
>  6 for each value i in a do
>  7     degree[i] ← degree[i] + 1
> ```

<!-- markdownlint MD028 -->

> __code flashcards__
>
> <pre>
> {@{<b>Convert-Prüfer-to-Tree</b>(<i>a</i>)}@}
>  1 {@{<i>n</i> ← <i>length</i>[<i>a</i>]}@}
>  2 {@{<i>T</i> ← a graph with <i>n</i> + 2 isolated nodes, numbered 1 <b>to</b> <i>n</i> + 2}@}
>  3 {@{<i>degree</i> ← an array of integers}@}
>  4 {@{<b>for</b> each node <i>i</i> in <i>T</i>}@} <b>do</b>
>  5     {@{<i>degree</i>[<i>i</i>] ← 1}@}
>  6 {@{<b>for</b> each value <i>i</i> in <i>a</i>}@} <b>do</b>
>  7     {@{<i>degree</i>[<i>i</i>] ← <i>degree</i>[<i>i</i>] + 1}@}
> </pre>

Next, for {@{each number in the sequence `a[i]`}@}, {@{find the first (lowest-numbered) node, `j`, with degree equal to 1}@}, {@{add the edge `(j, a[i])` to the tree, and decrement the degrees of `j` and `a[i]`}@}. In pseudo-code:

<pre>
 8 <b>for</b> each value <i>i</i> in <i>a</i> <b>do</b>
 9     <b>for</b> each node <i>j</i> in <i>T</i> <b>do</b>
10         <b>if</b> <i>degree</i>[<i>j</i>] = 1 <b>then</b>
11             Insert <i>edge</i>[<i>i</i>, <i>j</i>] into <i>T</i>
12             <i>degree</i>[<i>i</i>] ← <i>degree</i>[<i>i</i>] - 1
13             <i>degree</i>[<i>j</i>] ← <i>degree</i>[<i>j</i>] - 1
14             <b>break</b>
</pre>

> [!info]- code
>
> ```pseudocode
>  8 for each value i in a do
>  9     for each node j in T do
> 10         if degree[j] = 1 then
> 11             Insert edge[i, j] into T
> 12             degree[i] ← degree[i] - 1
> 13             degree[j] ← degree[j] - 1
> 14             break
> ```

<!-- markdownlint MD028 -->

> __code flashcards__
>
> <pre>
>  8 {@{<b>for</b> each value <i>i</i> in <i>a</i>}@} <b>do</b>
>  9     {@{<b>for</b> each node <i>j</i> in <i>T</i>}@} <b>do</b>
> 10         {@{<b>if</b> <i>degree</i>[<i>j</i>] = 1}@} <b>then</b>
> 11             {@{Insert <i>edge</i>[<i>i</i>, <i>j</i>] into <i>T</i>}@}
> 12             {@{<i>degree</i>[<i>i</i>] ← <i>degree</i>[<i>i</i>] - 1}@}
> 13             {@{<i>degree</i>[<i>j</i>] ← <i>degree</i>[<i>j</i>] - 1}@}
> 14             {@{<b>break</b>}@}
> </pre>

At {@{the end of this loop}@} {@{two nodes with degree 1 will remain (call them `u`, `v`)}@}. Lastly, {@{add the edge `(u,v)` to the tree}@}.<sup>[\[3\]](#^ref-3)</sup>

<pre>
15 <i>u</i> ← <i>v</i> ← 0
16 <b>for</b> each node <i>i</i> in <i>T</i>
17     <b>if</b> <i>degree</i>[<i>i</i>] = 1 <b>then</b>
18         <b>if</b> <i>u</i> = 0 <b>then</b>
19             <i>u</i> ← <i>i</i>
20         <b>else</b>
21             <i>v</i> ← <i>i</i>
22             <b>break</b>
23 Insert <i>edge</i>[<i>u</i>, <i>v</i>] into <i>T</i>
24 <i>degree</i>[<i>u</i>] ← <i>degree</i>[<i>u</i>] - 1
25 <i>degree</i>[<i>v</i>] ← <i>degree</i>[<i>v</i>] - 1
26 <b>return</b> <i>T</i>
</pre>

> [!info]- code
>
> ```pseudocode
> 15 u ← v ← 0
> 16 for each node i in T
> 17     if degree[i] = 1 then
> 18         if u = 0 then
> 19             u ← i
> 20         else
> 21             v ← i
> 22             break
> 23 Insert edge[u, v] into T
> 24 degree[u] ← degree[u] - 1
> 25 degree[v] ← degree[v] - 1
> 26 return T
> ```

<!-- markdownlint MD028 -->

> __code flashcards__
>
> <pre>
> 15 {@{<i>u</i> ← <i>v</i> ← 0}@}
> 16 {@{<b>for</b> each node <i>i</i> in <i>T</i>}@}
> 17     {@{<b>if</b> <i>degree</i>[<i>i</i>] = 1}@} <b>then</b>
> 18         {@{<b>if</b> <i>u</i> = 0}@} <b>then</b>
> 19             {@{<i>u</i> ← <i>i</i>}@}
> 20         <b>else</b>
> 21             {@{<i>v</i> ← <i>i</i>}@}
> 22             {@{<b>break</b>}@}
> 23 {@{Insert <i>edge</i>[<i>u</i>, <i>v</i>] into <i>T</i>}@}
> 24 {@{<i>degree</i>[<i>u</i>] ← <i>degree</i>[<i>u</i>] - 1}@}
> 25 {@{<i>degree</i>[<i>v</i>] ← <i>degree</i>[<i>v</i>] - 1}@}
> 26 {@{<b>return</b> <i>T</i>}@}
> </pre>

<!-- markdownlint MD028 -->

> [!tip] tips
>
> - alternative formulation ::@:: Let there be a sequence _N_ of _n_ labelled vertices and a Prüfer sequence. <p> Find the leaf (a node that is not in the Prüfer sequence) with the smallest label in the sequence _N_. Join it with the first node in the Prüfer sequence. Remove said leaf from the sequence _N_ and the first node from the Prüfer sequence. This may make a node in _N_ that was not a leaf now a leaf. <p> Repeat until there are only 2 nodes left in the sequence _N_. Connect those 2 nodes to get the tree.

## Cayley's formula

{@{The Prüfer sequence of a labeled tree on _n_ vertices}@} is {@{a unique sequence of length _n_ − 2 on the labels 1 to _n_}@}. For {@{a given sequence _S_ of length _n_ − 2 on the labels 1 to _n_}@}, __there is {@{a _unique_ labeled tree whose Prüfer sequence is _S_}@}__.

The immediate consequence is that Prüfer sequences provide {@{a [bijection](bijection.md) between the set of labeled trees on _n_ vertices and the set of sequences of length _n_ − 2 on the labels 1 to _n_}@}. {@{The latter set has size _n_<sup>_n_−2</sup>}@}, so the existence of this bijection {@{proves [Cayley's formula](Cayley's%20formula.md), i.e. that there are _n_<sup>_n_−2</sup> labeled trees on _n_ vertices}@}.

## other applications

- Cayley's formula can be {@{strengthened to prove the following claim}@}: <p> {@{The number of spanning trees in a complete graph $K_{n}$ with a degree $d_{i}$ specified for each vertex $i$}@} is equal to {@{the [multinomial coefficient](multinomial%20theorem.md#multinomial%20coefficients) $${\binom {n-2}{d_{1}-1,\,d_{2}-1,\,\dots ,\,d_{n}-1} }={\frac {(n-2)!}{(d_{1}-1)!(d_{2}-1)!\cdots (d_{n}-1)!} }.$$}@} <p> The proof follows by {@{observing that in the Prüfer sequence number $i$ appears exactly $d_{i}-1$ times}@}.<sup>[\[4\]](#^ref-4)</sup>
- Cayley's formula can be {@{generalized}@}: {@{a labeled tree is in fact a [spanning tree](spanning%20tree.md) of the labeled [complete graph](complete%20graph.md)}@}. By {@{placing restrictions on the enumerated Prüfer sequences}@}, similar methods can {@{give the number of spanning trees of a complete [bipartite graph](bipartite%20graph.md)}@}. If {@{_G_ is the complete bipartite graph with vertices 1 to _n_<sub>1</sub> in one partition and vertices _n_<sub>1</sub> + 1 to _n_ in the other partition}@}, {@{the number of labeled spanning trees of _G_}@} is {@{$n_{1}^{n_{2}-1}n_{2}^{n_{1}-1}$, where _n_<sub>2</sub> = _n_ − _n_<sub>1</sub>}@}.<sup>[\[4\]](#^ref-4)</sup>
- {@{Generating uniformly distributed random Prüfer sequences}@} and {@{converting them into the corresponding trees}@} is a straightforward method of {@{generating uniformly distributed random labelled trees}@}.<sup>[\[4\]](#^ref-4)</sup>

## references

This text incorporates [content](https://en.wikipedia.org/wiki/Prüfer_sequence) from [Wikipedia](Wikipedia.md) available under the [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/) license.

1. Prüfer, H. (1918). "Neuer Beweis eines Satzes über Permutationen". _Arch. Math. Phys_. __27__: 742–744. <a id="^ref-1"></a>^ref-1
2. Caminiti, S., Finocchi, I., Petreschi, R. (2007). ["On coding labeled trees"](https://doi.org/10.1016%2Fj.tcs.2007.03.009). _Theoretical Computer Science_. __382__ (2): 97–108. [doi](digital%20object%20identifier.md):[10.1016/j.tcs.2007.03.009](https://doi.org/10.1016%2Fj.tcs.2007.03.009). <a id="^ref-2"></a>^ref-2
3. Jens Gottlieb; Bryant A. Julstrom; Günther R. Raidl; Franz Rothlauf. (2001). ["Prüfer numbers: A poor representation of spanning trees for evolutionary search"](https://web.archive.org/web/20060926171652/http://www.ads.tuwien.ac.at/publications/bib/pdf/gottlieb-01.pdf) (PDF). _Proceedings of the Genetic and Evolutionary Computation Conference (GECCO-2001)_: 343–350. Archived from [the original](http://www.ads.tuwien.ac.at/publications/bib/pdf/gottlieb-01.pdf) (PDF) on 2006-09-26. <a id="^ref-3"></a>^ref-3
4. Kajimoto, H. (2003). "An Extension of the Prüfer Code and Assembly of Connected Graphs from Their Blocks". _[Graphs and Combinatorics](Graphs%20and%20Combinatorics.md)_. __19__ (2): 231–239. [doi](digital%20object%20identifier.md):[10.1007/s00373-002-0499-3](https://doi.org/10.1007%2Fs00373-002-0499-3). [S2CID](Semantic%20Scholar.md#S2CID) [22970936](https://api.semanticscholar.org/CorpusID:22970936). <a id="^ref-4"></a>^ref-4

## external links

- [Prüfer code](http://mathworld.wolfram.com/PrueferCode.html) – from [MathWorld](MathWorld.md)
