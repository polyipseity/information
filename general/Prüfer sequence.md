---
aliases:
  - Prüfer sequence
  - Prüfer sequences
tags:
  - flashcard/active/general/Pr_fer_sequence
  - language/in/English
---

# Prüfer sequence

In {{[combinatorial](combinatorics.md) [mathematics](mathematics.md)}}, {{the __Prüfer sequence__ (also __Prüfer code__ or __Prüfer numbers__) of a [labeled tree](tree%20(graph%20theory).md#labeled%20trees)}} is {{a unique [sequence](sequence.md) associated with the tree}}. {{The sequence for a tree on _n_ vertices}} has {{length _n_ − 2}}, and can be {{generated by a simple iterative algorithm}}. Prüfer sequences were first used by {{[Heinz Prüfer](Heinz%20Prüfer.md) to prove [Cayley's formula](cayley's%20formula.md) in 1918}}.<sup>[\[1\]](#^ref-1)</sup>

## algorithm to convert a tree into a Prüfer sequence

One can {{generate a labeled tree's Prüfer sequence}} by {{iteratively removing vertices from the tree until only two vertices remain}}. Specifically, {{consider a labeled tree _T_ with vertices {1, 2, ..., _n_}}}. At {{step _i_}}, {{remove the leaf with the smallest label and set the _i_-th element of the Prüfer sequence to be the label of this leaf's neighbour}}.

The Prüfer sequence of a labeled tree is {{unique and has length _n_ − 2}}.

{{Both coding and decoding}} can be {{reduced to integer radix sorting and parallelized}}.<sup>[\[2\]](#^ref-2)</sup>

### example

> {{![a labeled tree with Prüfer sequence](../archives/Wikimedia%20Commons/Tree%20graph.svg)}}
>
> {{A labeled tree with Prüfer sequence {4,4,4,5}.}}

Consider the above algorithm run on the tree shown to the right. Initially, vertex 1 is the leaf with the smallest label, so it is removed first and 4 is put in the Prüfer sequence. Vertices 2 and 3 are removed next, so 4 is added twice more. Vertex 4 is now a leaf and has the smallest label, so it is removed and we append 5 to the sequence. We are left with only two vertices, so we stop. The tree's sequence is {4,4,4,5}.

## algorithm to convert a Prüfer sequence into a tree

Let {a[1], a[2], ..., a[n]} be a Prüfer sequence:

The tree will have n+2 nodes, numbered from 1 to n+2. For each node set its degree to the number of times it appears in the sequence plus 1. For instance, in pseudo-code:

 __Convert-Prüfer-to-Tree__(_a_)
 1 _n_ ← _length_[_a_]
 2 _T_ ← a graph with _n_ + 2 isolated nodes, numbered 1 __to__ _n_ + 2
 3 _degree_ ← an array of integers
 4 __for__ each node _i_ in _T_ __do__
 5     _degree_[_i_] ← 1
 6 __for__ each value _i_ in _a_ __do__
 7     _degree_[_i_] ← _degree_[_i_] + 1

Next, for each number in the sequence a[i], find the first (lowest-numbered) node, j, with degree equal to 1, add the edge (j, a[i]) to the tree, and decrement the degrees of j and a[i]. In pseudo-code:

 8 __for__ each value _i_ in _a_ __do__
 9     __for__ each node _j_ in _T_ __do__
10         __if__ _degree_[_j_] = 1 __then__
11             Insert _edge_[_i_, _j_] into _T_
12             _degree_[_i_] ← _degree_[_i_] - 1
13             _degree_[_j_] ← _degree_[_j_] - 1
14             __break__
At the end of this loop two nodes with degree 1 will remain (call them u, v). Lastly, add the edge (u,v) to the tree.<sup>[\[3\]](#^ref-3)</sup>

15 _u_ ← _v_ ← 0
16 __for__ each node _i_ in _T_
17     __if__ _degree_[_i_] = 1 __then__
18         __if__ _u_ = 0 __then__
19             _u_ ← _i_
20         __else__
21             _v_ ← _i_
22             __break__
23 Insert _edge_[_u_, _v_] into _T_
24 _degree_[_u_] ← _degree_[_u_] - 1
25 _degree_[_v_] ← _degree_[_v_] - 1
26 __return__ _T_

## Cayley's formula

{{The Prüfer sequence of a labeled tree on _n_ vertices}} is {{a unique sequence of length _n_ − 2 on the labels 1 to _n_}}. For {{a given sequence _S_ of length _n_ − 2 on the labels 1 to _n_}}, __there is {{a _unique_ labeled tree whose Prüfer sequence is _S_}}__.

The immediate consequence is that {{Prüfer sequences provide a [bijection](bijection.md) between the set of labeled trees on _n_ vertices and the set of sequences of length _n_ − 2 on the labels 1 to _n_}}. {{The latter set has size _n_<sup>_n_−2</sup>}}, so the existence of this bijection {{proves [Cayley's formula](Cayley's%20formula.md), i.e. that there are _n_<sup>_n_−2</sup> labeled trees on _n_ vertices}}.

## other applications

- Cayley's formula can be {{strengthened to prove the following claim}}: <p> {{The number of spanning trees in a complete graph $K_{n}$ with a degree $d_{i}$ specified for each vertex $i$}} is equal to {{the [multinomial coefficient](multinomial%20theorem.md#multinomial%20coefficients) $${\binom {n-2}{d_{1}-1,\,d_{2}-1,\,\dots ,\,d_{n}-1} }={\frac {(n-2)!}{(d_{1}-1)!(d_{2}-1)!\cdots (d_{n}-1)!} }.$$}} <p> The proof follows by {{observing that in the Prüfer sequence number $i$ appears exactly $d_{i}-1$ times}}.<sup>[\[4\]](#^ref-4)</sup>
- Cayley's formula can be {{generalized}}: {{a labeled tree is in fact a [spanning tree](spanning%20tree.md) of the labeled [complete graph](complete%20graph.md)}}. By {{placing restrictions on the enumerated Prüfer sequences}}, similar methods can {{give the number of spanning trees of a complete [bipartite graph](bipartite%20graph.md)}}. If {{_G_ is the complete bipartite graph with vertices 1 to _n_<sub>1</sub> in one partition and vertices _n_<sub>1</sub> + 1 to _n_ in the other partition}}, {{the number of labeled spanning trees of _G_}} is {{$n_{1}^{n_{2}-1}n_{2}^{n_{1}-1}$, where _n_<sub>2</sub> = _n_ − _n_<sub>1</sub>}}.<sup>[\[4\]](#^ref-4)</sup>
- {{Generating uniformly distributed random Prüfer sequences and converting them into the corresponding trees}} is {{a straightforward method of generating uniformly distributed random labelled trees}}.<sup>[\[4\]](#^ref-4)</sup>

## references

This text incorporates [content](https://en.wikipedia.org/wiki/Prüfer_sequence) from [Wikipedia](Wikipedia.md) available under the [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/) license.

1. Prüfer, H. (1918). "Neuer Beweis eines Satzes über Permutationen". _Arch. Math. Phys_. __27__: 742–744. <a id="^ref-1"></a>^ref-1
2. Caminiti, S., Finocchi, I., Petreschi, R. (2007). ["On coding labeled trees"](https://doi.org/10.1016%2Fj.tcs.2007.03.009). _Theoretical Computer Science_. __382__ (2): 97–108. [doi](digital%20object%20identifier.md):[10.1016/j.tcs.2007.03.009](https://doi.org/10.1016%2Fj.tcs.2007.03.009). <a id="^ref-2"></a>^ref-2
3. Jens Gottlieb; Bryant A. Julstrom; Günther R. Raidl; Franz Rothlauf. (2001). ["Prüfer numbers: A poor representation of spanning trees for evolutionary search"](https://web.archive.org/web/20060926171652/http://www.ads.tuwien.ac.at/publications/bib/pdf/gottlieb-01.pdf) (PDF). _Proceedings of the Genetic and Evolutionary Computation Conference (GECCO-2001)_: 343–350. Archived from [the original](http://www.ads.tuwien.ac.at/publications/bib/pdf/gottlieb-01.pdf) (PDF) on 2006-09-26. <a id="^ref-3"></a>^ref-3
4. Kajimoto, H. (2003). "An Extension of the Prüfer Code and Assembly of Connected Graphs from Their Blocks". _[Graphs and Combinatorics](Graphs%20and%20Combinatorics.md)_. __19__ (2): 231–239. [doi](digital%20object%20identifier.md):[10.1007/s00373-002-0499-3](https://doi.org/10.1007%2Fs00373-002-0499-3). [S2CID](Semantic%20Scholar.md#S2CID) [22970936](https://api.semanticscholar.org/CorpusID:22970936). <a id="^ref-4"></a>^ref-4

## external links

- [Prüfer code](http://mathworld.wolfram.com/PrueferCode.html) – from [MathWorld](MathWorld.md)
