"""
This type stub file was generated by pyright.
"""

import logging
from collections import OrderedDict
from collections.abc import Callable, Iterable, Sequence
from typing import Any

import pandas as pd

"""country_converter - Classification converter for countries."""
COUNTRY_DATA_FILE: str
log: logging.Logger

def agg_conc(
    original_countries: str | Iterable[str] | pd.Series,
    aggregates: str | Iterable[dict[str, str | list[str] | None]] | pd.Series,
    missing_countries: str | bool | None = ...,
    merge_multiple_string: str | None = ...,
    log_missing_countries: Callable[[str], Any] | None = ...,
    log_merge_multiple_strings: Callable[[str], Any] | None = ...,
    coco: "CountryConverter" | None = ...,
    as_dataframe: bool | str | None = ...,
    original_countries_class: str | None = ...,
) -> OrderedDict[str, str | list[str] | None] | pd.Series | pd.DataFrame:
    """Build an aggregation concordance dict, vec or matrix.

    Parameters
    ----------
    original_countries: list or str
        List of countries to aggregated, also accepts and valid column name of
        CountryConverter.data (e.g. name_short, WIOD, ...)

    aggregates: list of dict or str
        List of aggregation information. This can either be dict mapping the
        names of 'original_countries' to aggregates, or a valid column name of
        CountryConverter.data Aggregation happens in order given in this
        parameter.  Thus, country assigned to an aggregate are not re-assigned
        by the following aggregation information.

    missing_countries: str, boolean, None
        Entry to fill in for countries in 'original_countries' which do not
        appear in 'aggregates'.  str: Use the given name for all missing
        countries True: Use the name in original_countries for missing
        countries False: Skip these countries None: Use None for these
        countries

    merge_multiple_string: str or None, optional
        If multiple correspondence entries are given in one of the aggregates
        join them with the given string (default: '_&_'.  To skip these entries,
        pass None.

    log_missing_countries: function, optional
        This function is called with country is country is in
        'original_countries' but missing in all 'aggregates'.
        For example, pass
        lambda x: logging.error('Country {} missing'.format(x))
        to log errors for such countries.  Default: do nothing

    log_merge_multiple_strings: function, optional
        Function to call for logging multiple strings, see
        log_missing_countries Default: do nothing

    coco: instance of CountryConverter, optional
        CountryConverter instance used for the conversion.  Pass a custom one
        if additional data is needed in addition to the custom country
        converter file.  If None (default), the bare CountryConverter is used

    as_dataframe: boolean or st, optional
        If False, output as OrderedDict.  If True or str, output as pandas
        dataframe.  If str and 'full', output as a full matrix, otherwise only
        two columns with the original and aggregated names are returned.

    original_countries_class: str, optional
        Valid column name of CountryConverter.data.  This parameter is needed
        if a list of countries is passed to 'original_countries' and strings
        corresponding to data in CountryConverter.data are used subsequently.
        Can be omitted otherwise.

    Returns
    -------
    OrderedDict or DataFrame (defined by 'as_dataframe')

    """
    ...

def match(
    list_a: Iterable[str],
    list_b: Iterable[str],
    not_found: str | None = ...,
    enforce_sublist: bool = ...,
    country_data: pd.DataFrame | str | None = ...,
    additional_data: pd.DataFrame | Sequence[pd.DataFrame] | Sequence[str] | None = ...,
) -> dict[str, str | list[str]]:
    """Match the country names given in two lists into a dictionary.

    This function matches names given in list_a to the one provided in list_b
    using regular expressions defined in country_data.

    Parameters
    ----------
    list_a : list
        Names of countries to identify
    list_b : list
        Master list of names for countries

    not_found : str, optional
        Fill in value for not found entries. If None, keep the input value
        (default: 'not found')

    enforce_sublist : boolean, optional
        If True, all entries in both list are list.
        If False(default), only multiple matches are list, rest are strings

    country_data : Pandas DataFrame or path to data file (optional)
        This is by default set to COUNTRY_DATA_FILE - the standard (tested)
        country list for coco.

    additional_data: (list of) Pandas DataFrames or data files (optional)
         Additional data to include for a specific analysis.
         This must be given in the same format as specified in the
         country_data file. (utf-8 encoded tab separated data, same
         column headers in all files)

    Returns
    -------
    dict:
        A dictionary with a key for every entry in list_a. The value
        correspond to the matching entry in list_b if found. If there is
        a 1:1 correspondence, the value is a str (if enforce_sublist is False),
        otherwise multiple entries as list.

    """
    ...

def convert(
    names: str | Iterable[str],
    src: str | None = ...,
    to: str | None = ...,
    enforce_list: bool = ...,
    not_found: str | None = ...,
    country_data: pd.DataFrame | str | None = ...,
    additional_data: pd.DataFrame | Sequence[pd.DataFrame] | Sequence[str] | None = ...,
) -> str | list[str | list[str]]:
    """Call CountryConverter.convert() - a simple wrapper.

    Uses the same parameters. This function has the same performance as
    CountryConverter.convert for one call; for multiple calls it is better to
    instantiate a common CountryConverter (this avoid loading the source data
    file multiple times).

    Note
    ----
    A lot of the functionality can also be done directly in Pandas DataFrames.
    For example:
    cc = CountryConverter()
    names = ['USA', 'SWZ', 'PRI']
    cc.data[cc.data['ISO3'].isin(names)][['ISO2', 'continent']]

    Parameters
    ----------
    names : str or list like
        Countries in 'src' classification to convert to 'to' classification

    src : str, optional
        Source classification

    to : str, optional
        Output classification (valid str for an index of the
        country data file), default: name_short

    enforce_list : boolean, optional
        If True, enforces the output to be list (if only one name was passed)
        or to be a list of lists (if multiple names were passed).  If False
        (default), the output will be a string (if only one name was passed) or
        a list of str and/or lists (str if a one to one matching, list
        otherwise).

    not_found : str, optional
        Fill in value for not found entries. If None, keep the input value
        (default: 'not found')

    country_data : Pandas DataFrame or path to data file (optional)
        This is by default set to COUNTRY_DATA_FILE - the standard (tested)
        country list for coco.

    additional_data: (list of) Pandas DataFrames or data files (optional)
         Additional data to include for a specific analysis.
         This must be given in the same format as specified in the
         country_data_file. (utf-8 encoded tab separated data, same
         column headers as in the general country data file)

    Returns
    -------
    list or str, depending on enforce_list

    """
    ...

class CountryConverter:
    """Main class for converting countries.

    Attributes
    ----------
    data : Pandas DataFrame
        Raw data read from the country data file

    """

    def __init__(
        self,
        country_data: str | pd.DataFrame | None = ...,
        additional_data: Sequence[str | pd.DataFrame] | None = ...,
        only_UNmember: bool = ...,
        include_obsolete: bool = ...,
    ) -> None:
        """Init for the main class.

        Parameters
        ----------
        country_data : Pandas DataFrame or path to data file
            This is by default set to COUNTRY_DATA_FILE - the standard
            (tested) country list for coco.

        additional_data: (list of) Pandas DataFrames or data files
            Additional data to include for a specific analysis.
            This must be given in the same format as specified in the
            country_data file. (utf-8 encoded tab separated data, same
            column headers in all files)

        only_UNmember: boolean, optional
            If True, only load countries currently being UN members from
            the standard data file. If False (default) load the full list
            of countries. In this case, also countries currently not existing
            (USSR) or with overlapping territories are included.

        include_obsolete: boolean, optional
            If True, includes countries that have become obsolete. If
            False (default) only includes currently valid countries.

        """
        ...

    def convert(
        self,
        names: str | Iterable[str],
        src: str | None = ...,
        to: str | None = ...,
        enforce_list: bool = ...,
        not_found: str | None = ...,
        exclude_prefix: Iterable[str] | None = ...,
    ) -> str | list[str | list[str]]:
        r"""Convert names from a list to another list.

        Note
        ----
        A lot of the functionality can also be done directly in Pandas
        DataFrames.
        For example:
        coco = CountryConverter()
        names = ['USA', 'SWZ', 'PRI']
        coco.data[coco.data['ISO3'].isin(names)][['ISO2', 'continent']]

        Parameters
        ----------
        names : str or list like
            Countries in 'src' classification to convert
            to 'to' classification

        src : str, optional
            Source classification. If None (default), each passed name is
            checked if it is a number (assuming UNnumeric) or 2 (ISO2) or
            3 (ISO3) characters long; for longer names 'regex' is assumed.

        to : str, optional
            Output classification (valid index of the country_data file),
            default: ISO3

        enforce_list : boolean, optional
            If True, enforces the output to be list (if only one name was
            passed) or to be a list of lists (if multiple names were passed).
            If False (default), the output will be a string (if only one name
            was passed) or a list of str and/or lists (str if a one to one
            matching, list otherwise).

        not_found : str, optional
            Fill in value for none found entries. If None, keep the input value
            (default: 'not found')

        exclude_prefix : list of valid regex strings
            List of indicators which negate the subsequent country/region.
            These prefixes and everything following will not be converted.
            E.g. 'Asia excluding China' becomes 'Asia' and
            'China excluding Hong Kong' becomes 'China' prior to conversion
            Default: ['excl\\w.*', 'without', 'w/o'])

        Returns
        -------
        list or str, depending on enforce_list

        """
        ...

    def pandas_convert(
        self,
        series: pd.Series,
        src: str | None = ...,
        to: str | None = ...,
        enforce_list: bool = ...,
        not_found: str | None = ...,
        exclude_prefix: Iterable[str] | None = ...,
    ) -> pd.Series:
        r"""Convert names from a Pandas Series to another Pandas Series.

        Using this method is faster than using the convert method when dealing with
        long Pandas Series. Depending on the size of the series, the performance increase
        can be very significant. The longer the series, the more significant the
        improvement. Note that if the series contains mostly unique values, more
        memory will be used, compared to the convert method.

        Parameters
        ----------
        series : str or list like
            Countries in 'src' classification to convert
            to 'to' classification.

        src : str, optional
            Source classification. If None (default), each passed name is
            checked if it is a number (assuming UNnumeric) or 2 (ISO2) or
            3 (ISO3) characters long; for longer names 'regex' is assumed.

        to : str, optional
            Output classification (valid index of the country_data file),
            default: ISO3

        enforce_list : boolean, optional
            If True, enforces the output to be list (if only one name was
            passed) or to be a list of lists (if multiple names were passed).
            If False (default), the output will be a string (if only one name
            was passed) or a list of str and/or lists (str if a one to one
            matching, list otherwise).

        not_found : str, optional
            Fill in value for none found entries. If None, keep the input value
            (default: 'not found')

        exclude_prefix : list of valid regex strings
            List of indicators which negate the subsequent country/region.
            These prefixes and everything following will not be converted.
            E.g. 'Asia excluding China' becomes 'Asia' and
            'China excluding Hong Kong' becomes 'China' prior to conversion
            Default: ['excl\\w.*', 'without', 'w/o'])

        Returns
        -------
        A Pandas Series containing list or str, depending on enforce_list

        """
        ...

    @property
    def valid_class(self) -> list[str]:
        """Valid strings for the converter."""
        ...

    @property
    def valid_country_classifications(self) -> list[str]:
        """All classifications available for countries without any aggregation."""
        ...

    def get_correspondence_dict(
        self,
        classA: str,
        classB: str,
        restrict: Sequence[bool] | pd.Series | None = ...,
        replace_numeric: bool = ...,
        replace_nan: Any | None = ...,
    ) -> dict[str, list[str] | None]:
        """Return a correspondence between classification A and B as dict.

        Parameters
        ----------
        classA: str
            Valid classification (column name of data)

        classB: str
            Valid classification (column name of data).

        restrict: boolean vector of size cc.data, optional
            where cc is the name of the CountryConverter instance.  Used to
            restrict the data sheet if necessary.  E.g. to convert to countries
            which were OECD members before 1970 use
            cc.get_correspondence_dict('ISO3', 'OECD', restrict=cc.data.OECD <
            1970)

        replace_numeric: boolean, optional
            If True (default) replace numeric values with the column header.
            This can be used to get a correspondence to, for example, 'OECD'
            instead of to the OECD membership years. Set to False if the actual
            numbers are required (as for UNcode).

        replace_nan: value or string, optional
            String/Value to replace nan values in classA. If this string is
            given, the return dict will include a key based on 'replace_nan'.
            Otherwise (default), these entries are omitted.

        Returns
        -------
        dict with
            keys: based on classA
            items: list of corresponding entries in classB or None

        """
        ...

def cli_output(conv_names: str | Iterable[str], sep: str) -> None:
    """Provide cli_output - helper function."""
    ...

def main() -> None:
    """Use for command line call."""
    ...
