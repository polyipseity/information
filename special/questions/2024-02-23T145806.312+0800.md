---
aliases: []
tags:
  - date/2024/02/23
  - language/in/English
  - question/algorithm/dynamic_programming
---

For a given $n$, from the set of integers from 1 to $n$, find the subset such that all its elements are coprime and the sum of the elements are as large as possible.

> [!tip]- tip
>
> - According to the [fundamental theorem of arithmetic](../../general/fundamental%20theorem%20of%20arithmetic.md), every integer greater than 1 can be represented uniquely as a product of [prime numbers](../../general/prime%20number.md).
> - 1 is coprime with every integer.
> - Two numbers are coprime with each other if they do not share any prime divisors.
>   - Multiple numbers are coprime with each other if every prime number appears at most once in their divisors.
> - Taking all the primes and 1 is not the right answer.
>   - Let $n = 9$. Taking all the primes and 1 yields $\set{1, 2, 3, 5, 7}$, which has a sum of 18, but $\set{1, 4, 5, 7, 9}$ also has all its elements being coprime and has a sum of 26.
>   - From the above example, one can see that multiplying primes instead of adding can yield a larger subset sum.
> - If a subset with all its element being coprime does not use all the prime numbers in their divisors, one can always produce a subset also with all its element being coprime that has a larger subset sum by adding the missing prime numbers to the subset.
>   - Let $n = 3$. $\set{1, 2}$ is worse than $\set{1, 2, 3}$.
> - For a subset with all its element being coprime uses all the prime numbers in their divisors, one may be able to produce a subset also with all its element being coprime that has a larger subset sum by repeating the same prime number for a single number in the subset.
>   - Let $n = 9$. $\set{1, 2, 3, 5, 7}$ is worse than $\set{1, 2 \cdot 2, 3 \cdot 3, 5, 7} = \set{1, 4, 5, 7, 9}$.

<!-- markdownlint MD028 -->

> [!success]- solution
>
> 1. Take the primes from 1 to $n$ in reverse order.
> 2. Start with an empty set that tracks the used prime numbers. Additionally, track the subset sum and the number to be added to the subset. The initial number to be added to the subset is 1 and the subset sum is thus also 1.
> 3. We perform a breadth-first search. At each step, generate the children tracking sets by adding another number to the subset. The number to be added is less than or equal to $n$, must be divisible by the currently greatest unused prime number, and only uses the currently unused prime numbers. The same prime number can be repeated. For each number satisfying the above criteria, generate a child, adding the new prime numbers to the tracking set and update the subset sum.
>     - Note that we do not need to check whether the new number to be added has appeared before. This is because the greatest prime factors of previous numbers must not appear in the prime factors of the new number.
> 4. Recursively repeat the above step until the tracking set has all the prime numbers has been used, at which point it has no children.
> 5. Find the tracking set with the greatest subset sum.
> 6. Follow from the tracking set to the tree root, collecting the numbers to be added to the subset. The resulting subset is the right answer.

<!-- markdownlint MD028 -->

> [!example]- implementations
>
> ```Python
> from dataclasses import dataclass
> from itertools import chain, combinations
> from typing import AbstractSet, Collection
> 
> 
> def get_primes_less_than(n: int):
>     sieve = [True] * (n // 2)
>     for i in range(3, int(n**0.5) + 1, 2):
>         if sieve[i // 2]:
>             sieve[i * i // 2 :: i] = [False] * ((n - i * i - 1) // (2 * i) + 1)
>     return tuple(
>         chain((2,) if n > 2 else (), (2 * i + 1 for i in range(1, n // 2) if sieve[i]))
>     )
> 
> 
> def get_greatest_number_less_than_with_factors(n: int, factors: Collection[int]):
>     @dataclass(frozen=True, slots=True)
>     class Node:
>         product: int
>         factors: tuple[int, ...]
> 
>     tree = Node(1, ())
>     if n <= 1:
>         return tree
>     node_queue, ends = [tree], list[Node]()
>     while node_queue:
>         node = node_queue.pop()
>         max_factor = (n - 1) // node.product
>         for factor in filter(lambda factor: factor <= max_factor, factors):
>             node_queue.append(Node(node.product * factor, node.factors + (factor,)))
>         else:
>             ends.append(node)
>     return max(ends, key=lambda node: node.product)
> 
> 
> def the_algorithm(n: int):
>     if n <= 0:
>         return frozenset()
> 
>     primes = frozenset(reversed(get_primes_less_than(n + 1)))
> 
>     @dataclass(frozen=True, slots=True)
>     class Node:
>         used_primes: AbstractSet[int]
>         num: int
>         sum: int
>         parent: "Node | None"
> 
>     tree = Node(frozenset(), 1, 1, None)
>     node_queue, ends = [tree], list[Node]()
>     while node_queue:
>         node = node_queue.pop(0)
>         unused_primes = sorted(primes - node.used_primes, reverse=True)
>         try:
>             greatest_prime = unused_primes.pop(0)
>         except IndexError:
>             ends.append(node)
>         else:
>             max_additional_factor = n // greatest_prime
>             possible_nums_and_primes = [(greatest_prime, frozenset({greatest_prime}))]
>             for num_of_additional_primes in range(len(unused_primes) + 1):
>                 for additional_primes in combinations(
>                     unused_primes, num_of_additional_primes
>                 ):
>                     if (
>                         additional_factor_node := get_greatest_number_less_than_with_factors(
>                             max_additional_factor + 1,
>                             (greatest_prime,) + additional_primes,
>                         )
>                     ).product > 1:
>                         possible_nums_and_primes.append(
>                             (
>                                 greatest_prime * additional_factor_node.product,
>                                 frozenset(
>                                     chain(
>                                         (greatest_prime,),
>                                         additional_factor_node.factors,
>                                     )
>                                 ),
>                             )
>                         )
> 
>             for new_num, new_num_prime_factors in possible_nums_and_primes:
>                 child_node = Node(
>                     node.used_primes | new_num_prime_factors,
>                     new_num,
>                     node.sum + new_num,
>                     node,
>                 )
>                 node_queue.append(child_node)
>     ret_node = max(ends, key=lambda node: node.sum)
>     ret = list[int]()
>     while ret_node:
>         ret.append(ret_node.num)
>         ret_node = ret_node.parent
>     ret.sort()
>     return tuple(ret)
> ```
