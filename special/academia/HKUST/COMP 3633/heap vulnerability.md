---
aliases:
  - heap vulnerabilities
  - heap vulnerability
tags:
  - flashcard/active/special/academia/HKUST/COMP_3633/heap_vulnerability
  - language/in/English
---

# heap vulnerability

## user perspective

Heap management in {@{C and C++}@} can be {@{boiled down to `malloc(size) -> pointer` and `free(pointer)`}@}. The former function {@{allocates a memory heap chunk and returns a pointer to it (or fails to allocate and returns a null pointer)}@}. The latter function {@{releases a previously allocated memory heap chunk pointed by the pointer}@}.

Memory heap chunks have the following properties: {@{dynamically allocated (size is specified at runtime), non-overlapping, and manually managed}@}.

To use manage heap safely, we need to satisfy {@{temporal and spatial}@} safety requirements. The former includes {@{not accessing freed chunks (double free, use after free), freeing chunks after use (memory leak), and initializing data before read (uninitialized data)}@}. The latter includes {@{not reading or writing out-of-bounds (buffer over-read, buffer overflow) and only freeing valid pointers returned by `malloc` (double free, invalid free)}@}.

> __vulnerability acronyms__
>
> - BOF ::@:: buffer overflow
> - UAF ::@:: use after free

## `pwndbg`

`pwndbg` is {@{a GNU Debugger (GDB) plugin}@}. It is available on {@{<https://github.com/pwndbg/pwndbg> or <https://pwndbg.re/>}@}.

To install `pwndbg`, {@{use a Linux distribution, clone the repository, and run `setup.sh` inside it}@}:

```shell
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh
```

To use it, {@{simply launch `gdb` after installation}@}. It is best to {@{familiarize yourself with [`gdb` common commands](../../../GNU%20Debugger.md#common%20commands) first}@} before using `pwndbg`.

## heap

The heap region is {@{usually a read-writeable memory segment after .bss (block starting symbol, containing statically allocated but uninitialized variables), maybe with a gap in between}@}. On Unix, it is created by {@{the `brk` syscall (which controls the amount of heap memory allocated to the process)}@}. For {@{large memory requests}@}, Unix OSes uses {@{the `mmap` syscall (which maps files or devices into memory)}@}.

### inspecting the heap

{@{`pwndbg`'s `vmmap`}@} can {@{inspect memory segments of a program}@}.

- `vmmap [<address|name>]` ::@:: display memory mappings information (filtered binary address or name)

`vmmap` outputs {@{a table showing information on all memory mappings of a program}@}. Each memory mapping is associated with {@{start (low; inclusive) address, end (high; exclusive) address, permissions, size, offset, and file}@}.

The addresses, sizes, and offsets are {@{in units of bytes and displayed in hexadecimal (not decimal)}@}. Size is {@{the distance between the start address and the end address}@}. File is {@{the file or device associated with the memory mapping}@}. Offset is {@{the position of the memory mapping in its associated file}@}. Permissions limit {@{actions we can perform on the data of the memory mapping}@}. The memory segments are also colored {@{according to the type of data they hold}@}.

Below are legends of what some values mean:

> __file__
>
> - `[heap]` ::@:: the heap (duh)
> - `[stack]` ::@:: the stack (duh)
> - `[vdso]` ::@:: the virtual dynamic shared object (vDSO), which contains a carefully selected set of kernel space routines for use by user space applications
> - `[vvar]` ::@:: the memory map containing kernel space variables for reading from kernel space routines in vDSO

<!-- markdownlint MD028 -->

> __permissions__
>
> The permissions are usually displayed in the order of {@{`rwxsp` (though `s` is omitted by `pwndbg`)}@}.
>
> - `r` ::@:: read, the ability to read from the memory mapping
> - `w` ::@:: write, the ability to write to the memory mapping
> - `x` ::@:: execute, the ability to execute data in the memory mapping as instructions
> - (omitted by `pwndbg`) `s` ::@:: shared, indicating the memory mapping _can be_ (but not necessarily _is_) shared by multiple processes
> - `p` ::@:: private (copy on write), indicating the memory mapping is used by the current process only; but it can still be shared with other processes until being written to by the current process, at which point the memory mapping is actually allocated and copied from the original shared memory, hence copy on write

## heap allocator

As {@{memory allocation is complicated}@}, the heap region is managed by {@{a _heap allocator_, which implements `malloc` and `free`}@}.

One major task of a heap allocator is {@{partitioning the heap}@}. The heap region is a {@{large continuous}@} memory, but {@{users usually only want a small continuous slice of it}@}. Furthermore, {@{the allocator cannot know what the users want ahead of time}@}.

An example of heap allocators is {@{`ptmalloc2`}@}.

### `ptmalloc2`
