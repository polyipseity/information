---
aliases:
  - COMP 3111H quiz 10
  - COMP3111H quiz 10
  - HKUST COMP 3111H quiz 10
  - HKUST COMP3111H quiz 10
tags:
  - date/2025/10/14
  - flashcard/active/special/academia/HKUST/COMP_3111H/questions/quiz_10
  - language/in/English
---

# quiz 10

- HKUST COMP 3111H

---

- type: quiz
- due: 2025-10-14T23:59:59+08:00
- points: 5
- questions: 5
- available: 2025-10-07T23:59:00+08:00/2025-10-14T23:59:59+08:00, P7DT59S
- time limit: none
- allowed attempts: 2

## hints

1. modular programming / module / abstraction ::@:: The internals of a module are hidden away. Interaction is defined via its interface only. The usage of the module by other modules can be understood by looking at its interface only \(ideally\). This reduces complexity of _understanding_ the system. <!--SR:!2026-01-25,67,310!2026-01-25,67,310-->
2. modular programming / module / encapsulation ::@:: When we want to modify a module, we only need to modify the module without changing other modules \(ideally\). The internals of a module can be changed without affecting other modules \(ideally\). This reduces _maintenance_ burden. <!--SR:!2026-01-25,67,310!2026-01-25,67,310-->
3. Unified Model Language / motivation ::@:: Models can describe the _essential_ details of reality only. This facilitates better communication \(e.g. ensure the system idea is the same\) among different stakeholders, e.g. clients, developers, etc. This also allows focusing on the _big picture_ without excess details \(e.g. programming-in-the-large, etc.\). <p> By reducing _complexity_, user requirements are better _understood_, architectures/designs are _cleaner_, and implementations are more _maintainable_. <!--SR:!2026-05-15,146,310!2026-02-16,74,270-->
4. defensive programming / simple definition ::@:: Protect yourself at all times! Never trust anyone! <p> Check all data from external sources. Check all input parameters. Handle bad inputs. <!--SR:!2026-01-25,67,310!2026-01-25,67,310-->
5. [code refactoring](../../../../../general/code%20refactoring.md) ::@:: In computer programming and software design, it is the process of restructuring existing source code—changing the _factoring_—without changing its external behavior. <!--SR:!2026-01-25,67,310!2026-01-25,67,310-->
